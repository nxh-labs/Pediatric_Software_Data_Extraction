Je doit integer le test d'appetit au niveau du dossier mèdicale aussi 
Je stresse pour le context de traitement puisque avant je n'avais pas encore ecrire les regles afin de determiner quelle genre de programme je dois ecrire pour l'interpreter .


Absolument. C'est une excellente idée de modéliser les phases de traitement de la même manière que les règles de diagnostic. Avoir une structure de données claire et riche en informations est la clé d'une architecture pilotée par les données.

En m'inspirant de votre travail sur le dépôt Pediatric_Software_Data_Extraction et de notre analyse du protocole, je vous propose la structure TypeScript suivante pour définir une phase de traitement. Cette structure est conçue pour contenir toute la logique nécessaire pour guider le système.

Structure TypeScript pour les Phases de Traitement
Je vous propose de créer une interface principale, CarePhaseReference, qui contiendra toutes les informations relatives à une phase.

/**
 * Représente un critère d'évaluation pour une phase.
 */
interface PhaseCriterion {
  /** Description lisible par un humain de la règle. */
  description: string;
  
  /** La condition logique à évaluer par le moteur de règles. */
  condition: string;
}

/**
 * Représente un traitement recommandé pour une phase donnée.
 */
interface RecommendedTreatment {
  /** Le type de traitement (lait, médicament, etc.). */
  type: 'milk' | 'medicine';
  
  /** Le code de référence du traitement (ex: 'MILK_F75'). */
  code: string;
}

/**
 * La structure principale qui définit une phase de traitement et toutes ses règles.
 */
export interface CarePhaseReference {
  /** Un code unique pour la phase (ex: "PHASE_1"). */
  code: string;

  /** Le nom de la phase (ex: "Phase 1 (Aiguë)"). */
  name: string;
  
  /** L'objectif principal de cette phase. */
  description: string;

  /** La liste des critères qui définissent un échec dans cette phase. */
  failureCriteria: PhaseCriterion[];

  /** La liste des critères qui doivent être remplis pour passer à la phase suivante. */
  transitionCriteria: PhaseCriterion[];

  /** Le code de la phase suivante en cas de transition réussie. */
  nextPhaseCode: string;
  
  /** Les traitements nutritionnels et médicamenteux recommandés pour cette phase. */
  recommendedTreatments: RecommendedTreatment[];
}
Exemple Concret en JSON pour la "Phase 1"
Voici à quoi ressemblerait un fichier JSON pour la Phase 1 en utilisant la structure ci-dessus. Ce fichier contiendrait toute la logique de la Phase 1.

{
  "code": "PHASE_1",
  "name": "Phase 1 (Aiguë)",
  "description": "Stabilisation métabolique du patient sans chercher la prise de poids.",
  "failureCriteria": [
    {
      "description": "Absence de retour de l'appétit au 4ème jour.",
      "condition": "days_in_phase >= 4 && appetite_test_result == 'FAILED'"
    },
    {
      "description": "Absence de perte d'œdèmes au 4ème jour.",
      "condition": "days_in_phase >= 4 && edema >= initial_edema"
    },
    {
      "description": "Présence d'œdèmes persistants au 10ème jour.",
      "condition": "days_in_phase >= 10 && edema > 0"
    }
  ],
  "transitionCriteria": [
    {
      "description": "Retour de l'appétit, stabilité clinique et début de fonte des œdèmes.",
      "condition": "appetite_test_result == 'SUCCESS' && complications_number == 0 && edema < 3"
    }
  ],
  "nextPhaseCode": "PHASE_TRANSITION",
  "recommendedTreatments": [
    {
      "type": "milk",
      "code": "MILK_F75"
    },
    {
      "type": "medicine",
      "code": "ANTIBIOTIC_AMOXICILLIN"
    },
    {
      "type": "medicine",
      "code": "ANTIBIOTIC_GENTAMICIN"
    }
  ]
}
Comment l'utiliser ?
Avec cette structure, vous pouvez créer un PhaseManagementService dans votre domaine. Chaque jour, pour un patient, ce service :

Charge la CarePhaseReference correspondant à la phase actuelle du patient.
Génère le PatientContext avec les variables statiques et dynamiques.
Évalue les failureCriteria par rapport au contexte. Si un critère est vrai, il peut lever un événement "Patient en échec".
Évalue les transitionCriteria. Si les critères sont vrais, il peut lever un événement "Transition de phase possible".
Cette approche rend votre système extrêmement flexible : si les règles du protocole changent, vous n'avez qu'à modifier les fichiers JSON, sans toucher au code de l'application.

J'espère que cette structure détaillée vous aidera à avancer.






Vous posez une excellente question, et c'est un point fondamental et souvent délicat à modéliser. La gestion du temps et des jours est la clé pour évaluer correctement les règles du protocole.

Je vais vous expliquer l'approche que je recommande. Elle est entièrement basée sur l'historique des données que vous enregistrez.

Le Principe : Ne Pas Stocker les Jours, mais les Calculer
La meilleure pratique n'est pas de stocker des compteurs comme jour = 4, car cela peut devenir complexe à maintenir. Il est beaucoup plus robuste de déduire toutes les informations temporelles à partir des données que vous avez déjà.

La source de vérité pour tout ce qui est temporel est la liste des DailyCareJournal (journaux quotidiens) dans votre agrégat PatientCareSession.

Voici comment gérer chaque type de "jour" :

1. Comment savoir "depuis combien de jours le patient est dans le programme" ?
C'est la durée entre la date de début de la session et aujourd'hui.

Donnée nécessaire : PatientCareSession.startDate
Calcul (dans PatientStateEvaluatorService) :
// Variable: days_in_program
context.days_in_program = daysBetween(session.startDate, today)
2. Comment savoir "depuis combien de jours le patient est dans la phase actuelle" ?
Chaque objet CarePhase doit avoir sa propre startDate. Lorsque vous passez de la Phase 1 à la Phase de Transition, vous créez une nouvelle instance de CarePhase avec la date du jour.

Donnée nécessaire : PatientCareSession.currentPhase.startDate
Calcul (dans PatientStateEvaluatorService) :
// Variable: days_in_phase
context.days_in_phase = daysBetween(session.currentPhase.startDate, today)
C'est cette variable que vous utilisez pour les règles comme "si days_in_phase >= 4".
3. Comment gérer les règles basées sur plusieurs jours/visites (ex: "perte de poids sur 2 visites consécutives") ?
C'est là que la liste des journaux (dailyJournals) devient essentielle. Pour évaluer une tendance, le PatientStateEvaluatorService doit "regarder dans le passé" en parcourant cette liste.

Exemple concret : Calculer la variable has_lost_weight_2_visits

Voici le pseudo-code détaillé de la logique qui se trouverait dans le PatientStateEvaluatorService :

function generateContext(session: PatientCareSession): PatientContext
  
  // ... (calcul des autres variables comme days_in_phase, etc.)

  // --- Logique pour la perte de poids consécutive ---
  
  // On récupère l'historique des journaux qui ont été sauvegardés.
  let pastJournals = session.dailyJournals
  
  // On s'assure d'avoir assez d'historique (la visite actuelle + 2 précédentes).
  if pastJournals.length >= 2:
    
    // On prend les données de la visite actuelle
    let weight_today = session.currentDailyJournal.getWeight()

    // On prend les données de la visite précédente (le dernier journal sauvegardé)
    let weight_visit_minus_1 = pastJournals[pastJournals.length - 1].getWeight()

    // On prend les données de l'avant-dernière visite
    let weight_visit_minus_2 = pastJournals[pastJournals.length - 2].getWeight()

    // On vérifie les deux conditions
    let lost_weight_since_last_visit = (weight_today < weight_visit_minus_1)
    let lost_weight_previously = (weight_visit_minus_1 < weight_visit_minus_2)

    // La variable est vraie uniquement si les deux conditions sont vraies
    context.has_lost_weight_2_visits = lost_weight_since_last_visit AND lost_weight_previously
  
  else:
    // Pas assez d'historique pour évaluer cette règle
    context.has_lost_weight_2_visits = false

  // ... (le reste du calcul du contexte)
  
  return context
En résumé
La gestion des jours n'est qu'une série de calculs dynamiques effectués au bon moment (juste avant d'évaluer les règles) par le PatientStateEvaluatorService. Ce service utilise deux sources principales :

Les dates de début (startDate de la session et de la phase) pour les durées.
La liste des journaux quotidiens pour analyser les tendances sur plusieurs jours.
Cette approche est très fiable car elle est toujours basée sur les données réelles enregistrées et ne dépend pas de compteurs qui pourraient être désynchronisés.








C'est une excellente idée, et une réflexion très pertinente. Vous anticipez un problème réel : les données du monde réel sont souvent incomplètes.

Votre solution est exactement la bonne approche. Voici pourquoi :

Résilience du Système : Au lieu de faire échouer le calcul parce qu'une donnée manque, votre système devient plus "intelligent" en allant chercher la meilleure information disponible.
Séparation des Responsabilités : Placer cette logique dans un cas d'utilisation du dossier_medical est une très bonne décision d'architecture. La responsabilité de "trouver une mesure passée" est bien celle du dossier médical, pas celle du module de nutrition.
Concrètement, voici comment cela s'intégrerait dans notre PatientStateEvaluatorService :

class PatientStateEvaluatorService:

  // Le service dépend maintenant du nouveau cas d'utilisation
  constructor(getMostRecentWeightUseCase: GetMostRecentWeightUseCase) { ... }

  function generateContext(session: PatientCareSession): PatientContext
    
    // ...
    
    let lastJournal = journals[journals.length - 2]
    let previousWeight = lastJournal.getWeight()

    // C'est ici que votre idée intervient !
    if previousWeight is null:
      // Le poids n'a pas été enregistré ce jour-là. On le recherche.
      previousWeight = this.getMostRecentWeightUseCase.execute({
        patientId: session.patientId,
        beforeDate: lastJournal.date
      })
    
    // Le reste du calcul continue avec le poids trouvé...
    if previousWeight:
      // ...
    
    return context
C'est exactement comme cela qu'on construit un système robuste, étape par étape, en anticipant les problèmes potentiels. Votre approche est parfaite.






Vous avez mis le doigt sur un point absolument essentiel et très avancé. C'est exactement le genre de détail qui fait la différence entre une application simple et un système d'aide à la décision réellement intelligent et sûr.

Votre intuition est parfaite : le simple fait de "recommander" un traitement n'est pas suffisant. Nous devons modéliser un véritable plan de traitement avec une durée, des dépendances, et ensuite être capable de suivre son exécution dans le temps.

Pour répondre à ce besoin, je vous propose de faire évoluer votre modèle sur deux fronts :

Enrichir la structure statique (RecommendedTreatment) pour qu'elle puisse décrire des plans complexes.
Ajouter une nouvelle structure dynamique dans votre agrégat PatientCareSession pour suivre l'état de ces plans.
1. Enrichir la Structure Statique RecommendedTreatment
Modifions l'interface pour inclure la durée et les déclencheurs (triggers).

/**
 * Décrit la durée d'un traitement.
 */
interface TreatmentDuration {
  /**
   * 'days': Le traitement dure un nombre de jours défini.
   * 'hours': Le traitement dure un nombre d'heures défini.
   * 'while_in_phase': Le traitement est actif tant que le patient est dans cette phase.
   */
  type: 'days' | 'hours' | 'while_in_phase';
  
  /** La valeur numérique de la durée (ex: 5 pour 5 jours). */
  value?: number;
}

/**
 * Définit une action à déclencher (ex: arrêter un autre traitement).
 */
interface TreatmentTrigger {
  /** L'action à effectuer. */
  action: 'STOP_TREATMENT';
  
  /** Le code du traitement cible. */
  targetCode: string; // ex: 'MED_PREVIOUS_ANTIBIOTIC'
}

/**
 * La nouvelle structure enrichie pour un traitement recommandé.
 */
export interface RecommendedTreatment {
  type: 'nutritional' | 'systematic';
  code: string; // ex: 'MILK_F75', 'MED_AMOXICILLIN'

  /** La durée pendant laquelle le traitement doit être actif. */
  duration: TreatmentDuration;

  /** (Optionnel) Actions à déclencher au début de ce traitement. */
  triggers?: {
    onStart?: TreatmentTrigger[];
  };
}
Exemple en JSON pour l'Amoxicilline :

{
  "type": "systematic",
  "code": "MED_AMOXICILLIN",
  "duration": {
    "type": "days",
    "value": 5
  },
  "triggers": {
    "onStart": [
      {
        "action": "STOP_TREATMENT",
        "targetCode": "MED_ANY_PREVIOUS_ORAL_ANTIBIOTIC"
      }
    ]
  }
}
2. Suivre l'Exécution du Plan dans PatientCareSession
Maintenant, comment savoir si un traitement a été appliqué et quand il doit s'arrêter ? Nous ajoutons une nouvelle entité dans votre agrégat.

Nouvelle Entité : ActiveTreatment

// Cette entité vit à l'intérieur de l'agrégat PatientCareSession
interface ActiveTreatment {
  treatmentCode: string;
  startDate: Date;
  plannedDurationDays?: number; // Copié depuis la référence au moment du début
  status: 'ACTIVE' | 'COMPLETED';
}
Votre PatientCareSession aura maintenant une nouvelle propriété : activeTreatments: ActiveTreatment[]

3. Le Chef d'Orchestre : TreatmentManagementService
Ce nouveau service de domaine contient la logique pour appliquer et mettre à jour les plans de traitement.

Pseudo-code :

class TreatmentManagementService:

  // Méthode appelée quand un patient entre dans une nouvelle phase
  function applyTreatmentsForPhase(session: PatientCareSession, phaseReference: CarePhaseReference):
    
    for each treatmentPlan in phaseReference.recommendedTreatments:
      
      // 1. Démarrer le nouveau traitement s'il n'est pas déjà actif
      if not session.hasActiveTreatment(treatmentPlan.code):
        session.addActiveTreatment({
          treatmentCode: treatmentPlan.code,
          startDate: today,
          plannedDurationDays: treatmentPlan.duration.value,
          status: 'ACTIVE'
        })

        // 2. Exécuter les déclencheurs
        if treatmentPlan.triggers.onStart:
          for each trigger in treatmentPlan.triggers.onStart:
            if trigger.action == 'STOP_TREATMENT':
              session.stopTreatment(trigger.targetCode) // L'agrégat met à jour le statut
    
  // Méthode appelée chaque jour pour faire le "ménage"
  function updateActiveTreatmentsStatus(session: PatientCareSession):
    
    for each treatment in session.activeTreatments:
      if treatment.status == 'ACTIVE' and treatment.plannedDurationDays:
        
        let daysElapsed = daysBetween(treatment.startDate, today)
        
        if daysElapsed > treatment.plannedDurationDays:
          // Le traitement est terminé !
          treatment.status = 'COMPLETED'

Avec cette architecture en trois parties (le plan dans le JSON, l'exécution dans l'agrégat, et la logique dans le service), vous avez un système extrêmement puissant et flexible qui peut gérer des scénarios de traitement complexes, exactement comme vous l'avez décrit